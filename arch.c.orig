#include "arch.h"

bfd_vma parse_call_address(bfd* target_binary, char* instruction) {
	void *self_dl_handle = dlopen(NULL, RTLD_NOW);


	// bfd_vma x86_64__parse_call_address(char*);
	//bfd_vma (*foo)(char*);
	*(void **) (&foo)= dlsym(self_dl_handle, "x86_64__parse_call_address");

	bfd_vma return_value = *foo(instruction);
	dlclose(self_dl_handle);
	return return_value;
}

bool is_call(bfd* target_binary, struct disassembly_ring* ring) {
	void *self_dl_handle = dlopen(NULL, RTLD_NOW);


	// bfd_vma x86_64__parse_call_address(char*);
	bool (*foo)(struct disassembly_ring*);
	foo = dlsym(self_dl_handle, "x86_64__is_call");

	bool return_value = foo(ring);
	dlclose(self_dl_handle);
	return return_value;
}

bfd_vma parse_ring_for_call_arg(bfd *target_binary, const struct disassembly_ring *ring,  const unsigned int arg_pos) {

	void *self_dl_handle = dlopen(NULL, RTLD_NOW);


	// What instruction set is the binary compiled for?
	// The printable_name member of the bfd_arch struct seems to follow a format whereby it may or may not include a colon. For instance, its value is "i386:x86-64" for an AMD64 binary and i386 for an old-school IA32 binary.
	// Apparently it's arch:mach though it can be just arch
	debug("Target compiled for %s\n", target_binary->arch_info->printable_name);

	// bfd_vma x86_64__parse_call_address(char*);
	bfd_vma (*foo)(const struct disassembly_ring*, const unsigned int);
	foo = dlsym(self_dl_handle, "x86_64__parse_ring_for_call_arg");
	if (!foo) {
		error("dlsym() failed: %s", dlerror());
		// TODO How do we bail gracefully?
	}

	bfd_vma return_value = foo(ring, arg_pos);
	dlclose(self_dl_handle);
	return return_value;

}
